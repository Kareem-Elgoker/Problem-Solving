struct MergeSortTree
{
    int tree_size;

    // change the data type suitable for the problem only for the seg_data vector
    vector<vector<int>> seg_data;
    vector<vector<int>> seg_data_lf;
    vector<vector<int>> seg_data_ri;

    MergeSortTree(int n)
    {
        tree_size = 1;
        while (tree_size < n) tree_size *= 2;

        seg_data.assign(2 * tree_size, {});
        seg_data_lf.assign(2 * tree_size, {});
        seg_data_ri.assign(2 * tree_size, {});
    }

    void merge(int ni, int lf, int ri)
    {
        int l = 0, r = 0, k = 0;
        int n = seg_data[lf].size();
        int m = seg_data[ri].size();

        seg_data[ni].assign(n + m, 0);
        seg_data_lf[ni].assign(n + m, 0);
        seg_data_ri[ni].assign(n + m, 0);

        while(l < n && r < m)
        {
            if(seg_data[lf][l] < seg_data[ri][r])
            {
                seg_data_lf[ni][k] = l;
                seg_data_ri[ni][k] = r - 1;
                seg_data[ni][k] = seg_data[lf][l];
                ++k;
                ++l;
            }
            else
            {
                seg_data_lf[ni][k] = l - 1;
                seg_data_ri[ni][k] = r;
                seg_data[ni][k] = seg_data[ri][r];
                ++r;
                ++k;
            }
        }

        while(l < n) {
            seg_data_lf[ni][k] = l;
            seg_data_ri[ni][k] = r - 1;
            seg_data[ni][k] = seg_data[lf][l];
            ++k;
            ++l;
        }
        while(r < m) {
            seg_data_lf[ni][k] = l - 1;
            seg_data_ri[ni][k] = r;
            seg_data[ni][k] = seg_data[ri][r];
            ++r;
            ++k;
        }
    }

    void init(vector<int> & nums, int ni, int lx, int rx)
    {
        if(rx - lx == 1)
        {
            if(lx < sz(nums))
                seg_data[ni] = {nums[lx]};
            return;
        }

        int mid = lx + (rx - lx) / 2;
        init(nums, 2 * ni + 1, lx, mid);
        init(nums, 2 * ni + 2, mid, rx);

        merge(ni, 2 * ni + 1, 2 * ni + 2);
    }
    void init(vector<int> & nums)
    {
        init(nums, 0, 0, tree_size);
    }

    int less_equal(int l, int r, int ni, int lx, int rx, int pos)
    {
        if(pos == -1)
            return 0;

        if(lx >= l && rx <= r)
        {
            return pos + 1;
        }
        if(lx >= r || rx <= l)
            return 0;

        int mid = lx + (rx - lx) / 2;

        int ans = less_equal(l, r, 2 * ni + 1, lx, mid, seg_data_lf[ni][pos]);
        ans += less_equal(l, r, 2 * ni + 2, mid, rx, seg_data_ri[ni][pos]);

        return ans;
    }


    // any query is zero indexed range and get the answer from l to r-1, i.e [l,r)

    int less_equal(int l, int r, int x)
    {
        auto it = upper_bound(seg_data[0].begin(), seg_data[0].end(), x);
        int ans = 0;
        if(it != seg_data[0].begin()) {
            --it;
            ans = less_equal(l, r, 0, 0, tree_size, it - seg_data[0].begin());
        }
        return ans;
    }

    int less(int l, int r, int x)
    {
        return less_equal(l, r, x - 1);
    }

    int equal(int l, int r, int x)
    {
        int ans = less_equal(l, r, x);
        ans -= less_equal(l, r, x - 1);
        return ans;
    }

    int greater(int l, int r, int x)
    {
        return (r - l) - less_equal(l, r, x);
    }

    int greater_equal(int l, int r, int x)
    {
        return (r - l) - less_equal(l, r, x - 1);
    }
};
